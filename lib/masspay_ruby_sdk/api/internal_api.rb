=begin
#MassPay API

#MassPay API

The version of the OpenAPI document: 0.1.4
Contact: support@masspay.io
Generated by: MassPay Inc.
OpenAPI Generator version: 6.5.0
=end

require 'cgi'

module MassPayRubySdk
  class InternalApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Commit payout transaction
    # Commits a previously initiated transaction.
    # @param user_token [String] Token representing the user to pay out
    # @param payout_token [String] Token representing the trsanaction. Retrieved from &#x60;/payout/{user_token}&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @return [PayoutTxnCommitResp]
    def commit_payout_txn_internal(user_token, payout_token, opts = {})
      data, _status_code, _headers = commit_payout_txn_internal_with_http_info(user_token, payout_token, opts)
      data
    end

    # Commit payout transaction
    # Commits a previously initiated transaction.
    # @param user_token [String] Token representing the user to pay out
    # @param payout_token [String] Token representing the trsanaction. Retrieved from &#x60;/payout/{user_token}&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @return [Array<(PayoutTxnCommitResp, Integer, Hash)>] PayoutTxnCommitResp data, response status code and response headers
    def commit_payout_txn_internal_with_http_info(user_token, payout_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.commit_payout_txn_internal ...'
      end
      # verify the required parameter 'user_token' is set
      if @api_client.config.client_side_validation && user_token.nil?
        fail ArgumentError, "Missing the required parameter 'user_token' when calling InternalApi.commit_payout_txn_internal"
      end
      # verify the required parameter 'payout_token' is set
      if @api_client.config.client_side_validation && payout_token.nil?
        fail ArgumentError, "Missing the required parameter 'payout_token' when calling InternalApi.commit_payout_txn_internal"
      end
      # resource path
      local_var_path = '/payout/{user_token}/{payout_token}/internal'.sub('{' + 'user_token' + '}', CGI.escape(user_token.to_s)).sub('{' + 'payout_token' + '}', CGI.escape(payout_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'Idempotency-Key'] = opts[:'idempotency_key'] if !opts[:'idempotency_key'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PayoutTxnCommitResp'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.commit_payout_txn_internal",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#commit_payout_txn_internal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Decrypt Statement JWT
    # 
    # @param token [String] JWT token
    # @param [Hash] opts the optional parameters
    # @return [Hash<String, String>]
    def decrypt_statement_jwt(token, opts = {})
      data, _status_code, _headers = decrypt_statement_jwt_with_http_info(token, opts)
      data
    end

    # Decrypt Statement JWT
    # 
    # @param token [String] JWT token
    # @param [Hash] opts the optional parameters
    # @return [Array<(Hash<String, String>, Integer, Hash)>] Hash<String, String> data, response status code and response headers
    def decrypt_statement_jwt_with_http_info(token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.decrypt_statement_jwt ...'
      end
      # verify the required parameter 'token' is set
      if @api_client.config.client_side_validation && token.nil?
        fail ArgumentError, "Missing the required parameter 'token' when calling InternalApi.decrypt_statement_jwt"
      end
      # resource path
      local_var_path = '/decrypt-statement-JWT'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token'] = token

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, String>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.decrypt_statement_jwt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#decrypt_statement_jwt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve available balances at distributors
    # 
    # @param [Hash] opts the optional parameters
    # @return [Array<DistributorsBalances200ResponseInner>]
    def distributors_balances(opts = {})
      data, _status_code, _headers = distributors_balances_with_http_info(opts)
      data
    end

    # Retrieve available balances at distributors
    # 
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<DistributorsBalances200ResponseInner>, Integer, Hash)>] Array<DistributorsBalances200ResponseInner> data, response status code and response headers
    def distributors_balances_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.distributors_balances ...'
      end
      # resource path
      local_var_path = '/distributors/balances'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<DistributorsBalances200ResponseInner>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.distributors_balances",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#distributors_balances\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Generate Invoice
    # Generate an invoice for the transaction
    # @param user_token [String] Token representing the user to pay out
    # @param payout_token [String] Token representing the trsanaction. Retrieved from &#x60;/payout/{user_token}&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @return [GenerateInvoice200Response]
    def generate_invoice(user_token, payout_token, opts = {})
      data, _status_code, _headers = generate_invoice_with_http_info(user_token, payout_token, opts)
      data
    end

    # Generate Invoice
    # Generate an invoice for the transaction
    # @param user_token [String] Token representing the user to pay out
    # @param payout_token [String] Token representing the trsanaction. Retrieved from &#x60;/payout/{user_token}&#x60;
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @return [Array<(GenerateInvoice200Response, Integer, Hash)>] GenerateInvoice200Response data, response status code and response headers
    def generate_invoice_with_http_info(user_token, payout_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.generate_invoice ...'
      end
      # verify the required parameter 'user_token' is set
      if @api_client.config.client_side_validation && user_token.nil?
        fail ArgumentError, "Missing the required parameter 'user_token' when calling InternalApi.generate_invoice"
      end
      # verify the required parameter 'payout_token' is set
      if @api_client.config.client_side_validation && payout_token.nil?
        fail ArgumentError, "Missing the required parameter 'payout_token' when calling InternalApi.generate_invoice"
      end
      # resource path
      local_var_path = '/payout/{user_token}/{payout_token}'.sub('{' + 'user_token' + '}', CGI.escape(user_token.to_s)).sub('{' + 'payout_token' + '}', CGI.escape(payout_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'Idempotency-Key'] = opts[:'idempotency_key'] if !opts[:'idempotency_key'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'GenerateInvoice200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.generate_invoice",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:OPTIONS, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#generate_invoice\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Generate pricing list
    # Generates a pricing list for the provided countries and email it to the requesting employee
    # @param [Hash] opts the optional parameters
    # @option opts [GeneratePricingListRequest] :generate_pricing_list_request 
    # @return [nil]
    def generate_pricing_list(opts = {})
      generate_pricing_list_with_http_info(opts)
      nil
    end

    # Generate pricing list
    # Generates a pricing list for the provided countries and email it to the requesting employee
    # @param [Hash] opts the optional parameters
    # @option opts [GeneratePricingListRequest] :generate_pricing_list_request 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def generate_pricing_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.generate_pricing_list ...'
      end
      # resource path
      local_var_path = '/generate_pricing_list'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'generate_pricing_list_request'])

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.generate_pricing_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#generate_pricing_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Transaction Status Callback
    # @param company_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def get_callback_company_id(company_id, opts = {})
      get_callback_company_id_with_http_info(company_id, opts)
      nil
    end

    # Transaction Status Callback
    # @param company_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def get_callback_company_id_with_http_info(company_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.get_callback_company_id ...'
      end
      # verify the required parameter 'company_id' is set
      if @api_client.config.client_side_validation && company_id.nil?
        fail ArgumentError, "Missing the required parameter 'company_id' when calling InternalApi.get_callback_company_id"
      end
      # resource path
      local_var_path = '/callback/{company_id}'.sub('{' + 'company_id' + '}', CGI.escape(company_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"InternalApi.get_callback_company_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#get_callback_company_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Development
    # 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def get_development_test(opts = {})
      get_development_test_with_http_info(opts)
      nil
    end

    # Development
    # 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def get_development_test_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.get_development_test ...'
      end
      # resource path
      local_var_path = '/development/test'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.get_development_test",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#get_development_test\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Initiate a payout transaction
    # Initiates a payout transaction to a provided user token.
    # @param user_token [String] Token representing the user to pay out
    # @param payout_txn [PayoutTxn] Payout parameters for a quote
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @option opts [Float] :limit Limit amount for transaction amount + fee. If fee + amount are higher than the limit, the output will automatically adjust to maximize the possible amount sent
    # @return [PayoutTxnResp]
    def initiate_payout_internal(user_token, payout_txn, opts = {})
      data, _status_code, _headers = initiate_payout_internal_with_http_info(user_token, payout_txn, opts)
      data
    end

    # Initiate a payout transaction
    # Initiates a payout transaction to a provided user token.
    # @param user_token [String] Token representing the user to pay out
    # @param payout_txn [PayoutTxn] Payout parameters for a quote
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @option opts [Float] :limit Limit amount for transaction amount + fee. If fee + amount are higher than the limit, the output will automatically adjust to maximize the possible amount sent
    # @return [Array<(PayoutTxnResp, Integer, Hash)>] PayoutTxnResp data, response status code and response headers
    def initiate_payout_internal_with_http_info(user_token, payout_txn, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.initiate_payout_internal ...'
      end
      # verify the required parameter 'user_token' is set
      if @api_client.config.client_side_validation && user_token.nil?
        fail ArgumentError, "Missing the required parameter 'user_token' when calling InternalApi.initiate_payout_internal"
      end
      # verify the required parameter 'payout_txn' is set
      if @api_client.config.client_side_validation && payout_txn.nil?
        fail ArgumentError, "Missing the required parameter 'payout_txn' when calling InternalApi.initiate_payout_internal"
      end
      pattern = Regexp.new(/^[\d.]+$/)
      if @api_client.config.client_side_validation && !opts[:'limit'].nil? && opts[:'limit'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"limit\"]' when calling InternalApi.initiate_payout_internal, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/payout/{user_token}/internal'.sub('{' + 'user_token' + '}', CGI.escape(user_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'Idempotency-Key'] = opts[:'idempotency_key'] if !opts[:'idempotency_key'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(payout_txn)

      # return_type
      return_type = opts[:debug_return_type] || 'PayoutTxnResp'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.initiate_payout_internal",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#initiate_payout_internal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Generate API Key
    # Generate API access key
    # @param [Hash] opts the optional parameters
    # @option opts [PostAccountApiKeyRequest] :post_account_api_key_request 
    # @return [PostAccountApiKey200Response]
    def post_account_api_key(opts = {})
      data, _status_code, _headers = post_account_api_key_with_http_info(opts)
      data
    end

    # Generate API Key
    # Generate API access key
    # @param [Hash] opts the optional parameters
    # @option opts [PostAccountApiKeyRequest] :post_account_api_key_request 
    # @return [Array<(PostAccountApiKey200Response, Integer, Hash)>] PostAccountApiKey200Response data, response status code and response headers
    def post_account_api_key_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.post_account_api_key ...'
      end
      # resource path
      local_var_path = '/account/api-key'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'post_account_api_key_request'])

      # return_type
      return_type = opts[:debug_return_type] || 'PostAccountApiKey200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.post_account_api_key",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#post_account_api_key\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Transaction Status Callback
    # @param company_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Object] :body 
    # @return [nil]
    def post_callback_company_id(company_id, opts = {})
      post_callback_company_id_with_http_info(company_id, opts)
      nil
    end

    # Transaction Status Callback
    # @param company_id [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Object] :body 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def post_callback_company_id_with_http_info(company_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.post_callback_company_id ...'
      end
      # verify the required parameter 'company_id' is set
      if @api_client.config.client_side_validation && company_id.nil?
        fail ArgumentError, "Missing the required parameter 'company_id' when calling InternalApi.post_callback_company_id"
      end
      # resource path
      local_var_path = '/callback/{company_id}'.sub('{' + 'company_id' + '}', CGI.escape(company_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"InternalApi.post_callback_company_id",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#post_callback_company_id\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Internal user update
    # Updates profile information for a provided user token.
    # @param user_token [String] user token that need to be updated
    # @param update_user [UpdateUser] Updated user object
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @option opts [Boolean] :is_compliance_update Whether this update was completed by compliance team
    # @option opts [String] :employee_username Hashed username of the employee making the update
    # @return [StoredUser]
    def update_user_internal(user_token, update_user, opts = {})
      data, _status_code, _headers = update_user_internal_with_http_info(user_token, update_user, opts)
      data
    end

    # Internal user update
    # Updates profile information for a provided user token.
    # @param user_token [String] user token that need to be updated
    # @param update_user [UpdateUser] Updated user object
    # @param [Hash] opts the optional parameters
    # @option opts [String] :idempotency_key Unique key to prevent duplicate processing
    # @option opts [Boolean] :is_compliance_update Whether this update was completed by compliance team
    # @option opts [String] :employee_username Hashed username of the employee making the update
    # @return [Array<(StoredUser, Integer, Hash)>] StoredUser data, response status code and response headers
    def update_user_internal_with_http_info(user_token, update_user, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.update_user_internal ...'
      end
      # verify the required parameter 'user_token' is set
      if @api_client.config.client_side_validation && user_token.nil?
        fail ArgumentError, "Missing the required parameter 'user_token' when calling InternalApi.update_user_internal"
      end
      # verify the required parameter 'update_user' is set
      if @api_client.config.client_side_validation && update_user.nil?
        fail ArgumentError, "Missing the required parameter 'update_user' when calling InternalApi.update_user_internal"
      end
      # resource path
      local_var_path = '/user/{user_token}/internal'.sub('{' + 'user_token' + '}', CGI.escape(user_token.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'is_compliance_update'] = opts[:'is_compliance_update'] if !opts[:'is_compliance_update'].nil?
      query_params[:'employee_username'] = opts[:'employee_username'] if !opts[:'employee_username'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'Idempotency-Key'] = opts[:'idempotency_key'] if !opts[:'idempotency_key'].nil?

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_user)

      # return_type
      return_type = opts[:debug_return_type] || 'StoredUser'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.update_user_internal",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#update_user_internal\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload a batch
    # Uploads an XLSX file with batch instructions
    # @param [Hash] opts the optional parameters
    # @option opts [UploadBatchRequest] :upload_batch_request 
    # @return [nil]
    def upload_batch(opts = {})
      upload_batch_with_http_info(opts)
      nil
    end

    # Upload a batch
    # Uploads an XLSX file with batch instructions
    # @param [Hash] opts the optional parameters
    # @option opts [UploadBatchRequest] :upload_batch_request 
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def upload_batch_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: InternalApi.upload_batch ...'
      end
      # resource path
      local_var_path = '/batch'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'upload_batch_request'])

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['api_key', 'AUTHORIZER_NAME']

      new_options = opts.merge(
        :operation => :"InternalApi.upload_batch",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: InternalApi#upload_batch\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
